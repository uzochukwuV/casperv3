use odra::{
    casper_types::{U128, U256},
    prelude::*,
    ContractRef,  // Required for using .new() on contract references
};

// Import the contract ref types generated by Odra
use crate::pool::IPoolContractRef;
use crate::factory::IFactoryContractRef;


/// NFT-based position manager
/// Wraps pool positions as NFTs for easier management
#[odra::module]
pub struct PositionManager {
    // NFT state
    next_token_id: Var<U256>,
    owners: Mapping<U256, Address>,
    balances: Mapping<Address, U256>,
    token_approvals: Mapping<U256, Address>,

    // Position data
    positions: Mapping<U256, PositionData>,

    // Factory reference
    factory: Var<Address>,
}

/// Position data stored for each NFT
#[odra::odra_type]
pub struct PositionData {
    pub pool: Address,
    pub tick_lower: i32,
    pub tick_upper: i32,
    pub liquidity: U128,
}

/// Parameters for minting a new position
#[odra::odra_type]
pub struct MintParams {
    pub token0: Address,
    pub token1: Address,
    pub fee: u32,
    pub tick_lower: i32,
    pub tick_upper: i32,
    pub amount0_desired: U256,
    pub amount1_desired: U256,
    pub amount0_min: U256,
    pub amount1_min: U256,
    pub recipient: Address,
}

/// Result of minting a position
#[odra::odra_type]
pub struct MintResult {
    pub token_id: U256,
    pub liquidity: U128,
    pub amount0: U256,
    pub amount1: U256,
}

#[odra::module]
impl PositionManager {
    /// Initialize the position manager
    pub fn init(&mut self, factory: Address) {
        self.factory.set(factory);
        self.next_token_id.set(U256::one());
    }

    /// Mint a new position NFT
    ///
    /// # Arguments
    /// * `params` - Minting parameters
    ///
    /// # Returns
    /// (token_id, liquidity, amount0, amount1)
    pub fn mint(&mut self, params: MintParams) -> MintResult {
        // Get pool from factory
        let factory_ref = IFactoryContractRef::new(self.env(), self.factory.get().unwrap());
        let pool_address = factory_ref.get_pool(params.token0, params.token1, params.fee)
            .expect("Pool does not exist");

        let mut pool = IPoolContractRef::new(self.env(), pool_address);

        // Calculate liquidity amount
        // For now, use a simplified calculation
        // In production, this should use LiquidityMath properly
        let liquidity = params.amount0_desired.as_u128().into();

        // Add liquidity to pool
        let (amount0, amount1) = pool.mint(
            self.env().self_address(),
            params.tick_lower,
            params.tick_upper,
            liquidity,
        );

        // Check slippage
        assert!(amount0 >= params.amount0_min, "Slippage: amount0 too low");
        assert!(amount1 >= params.amount1_min, "Slippage: amount1 too low");

        // Mint NFT
        let token_id = self.next_token_id.get_or_default();
        self.next_token_id.set(token_id + U256::one());

        self._mint(params.recipient, token_id);

        // Store position data
        let position_data = PositionData {
            pool: pool_address,
            tick_lower: params.tick_lower,
            tick_upper: params.tick_upper,
            liquidity,
        };
        self.positions.set(&token_id, position_data);

        MintResult {
            token_id,
            liquidity,
            amount0,
            amount1,
        }
    }

    /// Increase liquidity in an existing position
    pub fn increase_liquidity(
        &mut self,
        token_id: U256,
        amount0_desired: U256,
        _amount1_desired: U256,  // TODO: Use this in proper liquidity calculation
        amount0_min: U256,
        amount1_min: U256,
    ) -> (U128, U256, U256) {
        // Verify ownership
        let owner = self.owners.get(&token_id).expect("Position does not exist");
        assert!(owner == self.env().caller(), "Not position owner");

        let mut position_data = self.positions.get(&token_id).expect("Position not found");
        let mut pool = IPoolContractRef::new(self.env(), position_data.pool);

        // Calculate additional liquidity
        let additional_liquidity = amount0_desired.as_u128().into();

        // Add to pool
        let (amount0, amount1) = pool.mint(
            self.env().self_address(),
            position_data.tick_lower,
            position_data.tick_upper,
            additional_liquidity,
        );

        // Check slippage
        assert!(amount0 >= amount0_min, "Slippage: amount0 too low");
        assert!(amount1 >= amount1_min, "Slippage: amount1 too low");

        // Update position
        position_data.liquidity = position_data.liquidity + additional_liquidity;
        self.positions.set(&token_id, position_data);

        (additional_liquidity, amount0, amount1)
    }

    /// Decrease liquidity in an existing position
    pub fn decrease_liquidity(
        &mut self,
        token_id: U256,
        liquidity: U128,
        amount0_min: U256,
        amount1_min: U256,
    ) -> (U256, U256) {
        // Verify ownership
        let owner = self.owners.get(&token_id).expect("Position does not exist");
        assert!(owner == self.env().caller(), "Not position owner");

        let mut position_data = self.positions.get(&token_id).expect("Position not found");
        let mut pool = IPoolContractRef::new(self.env(), position_data.pool);

        // Remove from pool
        let (amount0, amount1) = pool.burn(
            position_data.tick_lower,
            position_data.tick_upper,
            liquidity,
        );

        // Check slippage
        assert!(amount0 >= amount0_min, "Slippage: amount0 too low");
        assert!(amount1 >= amount1_min, "Slippage: amount1 too low");

        // Update position
        position_data.liquidity = position_data.liquidity - liquidity;
        self.positions.set(&token_id, position_data);

        (amount0, amount1)
    }

    /// Collect fees and tokens from a position
    pub fn collect(
        &mut self,
        token_id: U256,
        recipient: Address,
        amount0_max: U128,
        amount1_max: U128,
    ) -> (U128, U128) {
        // Verify ownership
        let owner = self.owners.get(&token_id).expect("Position does not exist");
        assert!(owner == self.env().caller(), "Not position owner");

        let position_data = self.positions.get(&token_id).expect("Position not found");
        let mut pool = IPoolContractRef::new(self.env(), position_data.pool);

        // Collect from pool
        let (amount0, amount1) = pool.collect(
            recipient,
            position_data.tick_lower,
            position_data.tick_upper,
            amount0_max,
            amount1_max,
        );

        (amount0, amount1)
    }

    /// Internal: Mint NFT
    fn _mint(&mut self, to: Address, token_id: U256) {
        self.owners.set(&token_id, to);

        let balance = self.balances.get(&to).unwrap_or_default();
        self.balances.set(&to, balance + U256::one());
    }

    /// Get position data
    pub fn get_position(&self, token_id: U256) -> Option<PositionData> {
        self.positions.get(&token_id)
    }

    /// Get owner of a position NFT
    pub fn owner_of(&self, token_id: U256) -> Option<Address> {
        self.owners.get(&token_id)
    }

    /// Get balance of an address
    pub fn balance_of(&self, owner: Address) -> U256 {
        self.balances.get(&owner).unwrap_or_default()
    }

    pub fn get_next_token_id(&self) -> U256 {
        self.next_token_id.get_or_default()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use odra::host::Deployer;

    #[test]
    fn test_position_manager_init() {
        let env = odra_test::env();
        let factory = env.get_account(1);

        let init_args = PositionManagerInitArgs { factory };
        let manager = PositionManager::deploy(&env, init_args);

        assert_eq!(manager.get_next_token_id(), U256::one());
    }
}
